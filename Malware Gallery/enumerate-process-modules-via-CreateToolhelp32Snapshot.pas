uses
  System.SysUtils, Winapi.Windows, Winapi.TlHelp32, Generics.Collections;

// ...

function EnumerateProcessModules(const ATargetProcessId : Cardinal; var AList : TList<TModuleEntry32>) : Cardinal;
begin
  result := 0;
  ///

  if not Assigned(AList) then
    AList := TList<TModuleEntry32>.Create()
  else
    AList.Clear();
  ///

  var hSnapshot := CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ATargetProcessId);
  if hSnapshot = INVALID_HANDLE_VALUE then
    raise EWindowsException.Create('CreateToolhelp32Snapshot');
  try
    var AModuleEntry32 : TModuleEntry32;
    AModuleEntry32.dwSize := SizeOf(TModuleEntry32);

    if not Module32First(hSnapshot, AModuleEntry32) then
      raise EWindowsException.Create('Module32First');

    repeat
      AList.Add(AModuleEntry32);
    until Module32Next(hSnapshot, AModuleEntry32) = False;

    ///
    result := AList.Count;
  finally
    CloseHandle(hSnapshot);
  end;
end;

// ...

begin
  var AList := TList<TModuleEntry32>.Create();
  try
    EnumerateProcessModules(GetCurrentProcessId(), AList);
    ///

    for var AModuleEntry in AList do
      WriteLn(Format('[0x%p] -> %s', [
        AModuleEntry.modBaseAddr,
        AModuleEntry.szExePath
      ]));
  finally
    FreeAndNil(AList);
  end;

// ...