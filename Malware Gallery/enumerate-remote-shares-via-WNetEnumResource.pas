uses
  System.SysUtils, Winapi.Windows, Generics.Collections;

// ...

function EnumerateRemoteShares(var AList : TList<String>) : Cardinal;
begin
  result := 0;
  ///

  if not Assigned(AList) then
    AList := TList<String>.Create()
  else
    AList.Clear();

  var AEnumHandle : THandle;

  var AResult := WNetOpenEnumW(
    RESOURCE_CONNECTED,
    RESOURCETYPE_DISK,
    0,
    nil,
    AEnumHandle
  );

  if AResult <> NO_ERROR then
    raise EWindowsException.Create('WNetOpenEnumW');
  try
    const AMinimumBufferSize = 16 * 1024; // 16KiB
    // 16KiB should be way enought!

    var ABufferSize : DWORD := AMinimumBufferSize;
    var pBuffer : PNetResource;
    GetMem(pBuffer, ABufferSize);
    try
      var AEntriesCount := DWORD(-1); // All
      var ABufferRealSize := ABufferSize;

      AResult := WNetEnumResourceW(
        AEnumHandle,
        AEntriesCount,
        pBuffer,
        ABufferRealSize
      );

      if AResult <> NO_ERROR then
        raise EWindowsException.Create('WNetEnumResourceW', AResult);

      for var I := 0 to AEntriesCount -1 do begin
        var pCurrentNetworkResource := PNetResource(NativeUInt(pBuffer) + (I * SizeOf(TNetResource)));

        AList.Add(pCurrentNetworkResource^.lpRemoteName);
      end;
    finally
      FreeMem(pBuffer, ABufferSize);
    end;
  finally
    WNetCloseEnum(AEnumHandle);
  end;

  ///
  result := AList.Count;
end;

// ...

begin
  try
    var AList := TList<String>.Create();
    try
      var ARemoteSharesCount := EnumerateRemoteShares(AList);

      if ARemoteSharesCount > 0 then begin
        WriteLn(Format('Displaying %d share(s):', [ARemoteSharesCount]));

        for var ARemoteShare in AList do
          WriteLn(#9 + ARemoteShare);
      end else
        WriteLn('No remote share so far!');
    finally
      FreeAndNil(AList);
    end;
  except
    on E : Exception do
      WriteLn(E.Message);
  end;

// ...